인터페이스
표현법 : 접근제한자 interface 인터페이스명 {}

- 무조건 상수필드와 추상메소드로만 이루어진 추상클래스의 변형체다.
- 인터페이스에서 선언한 필드는 명시하지 않아도 무조건 상수필드로 사용된다.
- 인터페이스에서 선언한 메소드는 명시하지 않아도 무조건 추상 메소드이다.
- 공통적으로 구현해야하는 메소드가 존재할 경우 인터페이스를 만들어서 상속하게 한다.
- 인터페이스는 다중 상속 허용한다.
   ( 결국 메소드에 대한 정의만 하고있는게 인터페이스이기 때문에, 여러 메소드가 겹치더라도 최종
     구현은 구현 클래스에서 이루어질것이기 때문에 다중구현을 받아도 문제가 없다.
- 추상 클래스와 다르게 강한 규칙성과 강제성을 가짐

추상 클래스와 인터페이스 공통점
- 객체 생성은 안되나, 참조변수로서 사용이 가능하다. ( 즉, 다형성을 적용할 수 있다.)
- 상속(구현)하는 클래스에 추상메소드를 구현하도록 강제한다.

추상클래스와 인터페이스 차이점
- 추상클래스는 클래스 내에 인스턴스 변수, 메소드를 생성이 가능하고, 추상메소드가 포함되어있거나
  abstract 키워드로 클래스가 정의되어 있고
  인터페이스는 인스턴스 변수, 일반메소드 생성이 불가하며 모든 변수는 상수필드, 모든 메소드는 추상메소드로 정의되어 있다.

- 존재하는 목적이 다르다.
  추상클래스는 추상클래스를 상속받아서 기능을 이용하고, 클래스를 "확장" 하는데 목적이 있다.
  인터페이스는 클래스의 기능(함수)구현을 강제하기 위해 사용된다. 즉, 기능구현을 강제함으로써 인터페이스를
  상속받은 모든 킅래스에 동일한 동작을 보장할 수 있다.

extends 와 implements
- 클래스간 상속 관계일 때 : 클래스명 extends 부모클래스명
- 클래스와 인터페이스의 구현 관계일 때 : 클래스명 implements 인터페이스명, 인터페이스명 ...
- 인터페이스간의 상속 관계일때 : 인터페이스명 extends 인터페이스명, 인터페이스명

필드
int num = 5; // 인터페이스에서 필드는 명시하지 않아도 무조건 상수필드로 사용된다.

메소드
public void eat(); // 인터페이스에서 몸통부를 구현해도 에러가 안난다.
                   // abstract 자동으로 선언되어 있다.
인터페이스에서는 추상메소드만 정의할 수 있기때문에 메소드의 몸통부 작석이 불가능하며 abstract 키워드가 자동으로 추가된다.


클래스에서 클래스를 상속 받을때 : extends 클래스(단일상속만 가능) : 화살표 선언
클래스에서 인터페이스를 구현할때 : implements 인터페이스, 인터페이스(다중구현가능) : 화살표 점선
인터페이스에서 인터페이스를 상속 : extends 인터페이스, 인터페이스(다중상속가능) : 화살표 실선

