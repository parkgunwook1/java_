시간 복잡도
알고리즘에서 시간 복잡도는 주어진 문제를 해결하기 위한 연산 횟수를 말한다. 일반적으로 수행 시간은 1억 번의 연산을 1초의 시간으로 간주하여 예측한다.

시간 복잡도 유형
- 빅 오메가 : 최선일 때 연산횟수 나타낸 표기법
- 빅 세타 : 보통일 때 연산 횟수 나타낸 표기법
- 빅 오 : 최악일 때 연산횟수 나타낸 표기법

코딩 테스트에서는 빅-오 표기법을 기준으로 수행 시간 계산하는 것이 좋다.
시간 복잡도를 판단할 때는 최악일 때를 염두에 둬야 한다.

시간 복잡도를 바탕으로 코드 로직 개선하기
시간 복잡도는 작성한 코드의 비효율적인 로직을 개선하는 바탕으로도 사용할 수 있다.
시간복잡도를 활용해 코드의 시간복잡도 도출하는 2가지 기준
1. 상수는 시간 복잡도 계산에서 제외한다.
2. 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 된다.

int N = 10000;
for (int i = 0; i < N; i++)  {
  for (int j = 0; j < N; j++){
 }
}
위의 코드 시간복잡도는 N의 2제곱이다.
만약 일반 for 문이 10개 더 있다 하더라도 N의 2제곱이다.

----------------------------------------------

디버깅

코드 논리 오류를 찾을 수 있는 가장 최선의 방법은 '디버깅' 이다.
프로그램에서 발생하는 문법 오류나, 논리 오류를 찾아 바로 잡는것이 디버깅이다.

문법 오류는 컴파일러가 자동으로 찾아 주므로 테스트할 때 문제가 되지 않는다. 반면에 논리 오류는 사용자의 의도와 다르게 동작하는 것이며 다양하게 발생한다.
디버깅은 그냥 알아두는 것만 아니라, 코테를 준비하면 반드시 해야하는 것이다.

반복문을 사용할 때마다 범위와 시작 인덱스를 꼼꼼하게 확인하고, 혹시 모를 오입력을 대비해 디버깅 하는 습관을 들여야한다.

디버깅을 이용하면 자신이 작성한 로직에 존재하는 논리 오류를 좀 더 효율적으로 발견할 수 있다. 익숙해지기를 바란다.

자료형은 처음부터 long 형으로 선언하자.